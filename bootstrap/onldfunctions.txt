function heapYValues(itemsToHeap, xScale, radius, sampleIndex, areaTopY, areaBottomY){
var popMean = 0;
var maxY = 0;
for(var j = 0; j < itemsToHeap.length;j++){
	var thisItem = itemsToHeap[j];
	thisItem.xPerSample[sampleIndex] = xScale(thisItem.value);
	thisItem.yPerSample[sampleIndex] = 0;
	thisItem.level = 0;
	popMean += thisItem.value;
	if(j != 0){
		var lastItem = itemsToHeap[j-1];
		if(thisItem.xPerSample[sampleIndex] - lastItem.xPerSample[sampleIndex] <= radius*0.2){
			thisItem.level = lastItem.level + 1;
			thisItem.yPerSample[sampleIndex] = lastItem.yPerSample[sampleIndex] +((radius*2) * Math.pow(0.99,thisItem.level));
			if(thisItem.yPerSample[sampleIndex] > maxY){
				maxY = thisItem.yPerSample[sampleIndex];
			}
		}
	}
}
popMean = popMean/population.length;
yScale = d3.scale.linear().range([areaBottomY,Math.max(areaBottomY - maxY,areaTopY+radius*2)]);
yScale.domain([0,maxY]);
for(var l = 0; l<itemsToHeap.length;l++){
	itemsToHeap[l].yPerSample[sampleIndex] = yScale(itemsToHeap[l].yPerSample[sampleIndex]);
}
return popMean;
}
function heapYValues2(itemsToHeap, xScale, radius, sampleIndex, areaTopY, areaBottomY){
var levels = [[]];
var mean = 0;
var maxY = 0;
for(var i = 0; i < itemsToHeap.length;i++){
	var thisItem = itemsToHeap[i];
	thisItem.xPerSample[sampleIndex] = xScale(thisItem.value);
	thisItem.yPerSample[sampleIndex] = 0;
	var closest = null;
	var dist = -1;
	for(var k = levels.length-1;k>=0;k--){
		for(var j = 0; j< levels[k].length;j++){
			var thisDist = Math.abs(levels[k][j].xPerSample[sampleIndex] - thisItem.xPerSample[sampleIndex]);
			if(dist < 0 | thisDist < dist){
				dist = thisDist;
				closest = levels[k][j];
			}
		}
		if(dist > 0 && dist < radius * 0.5){
			if(closest.level  >= levels.length) levels.push([]);
				thisItem.level = closest.level + 1;
				thisItem.yPerSample[sampleIndex] = closest.yPerSample[sampleIndex] +((radius*2) * Math.pow(1,thisItem.level));
				levels[thisItem.level - 1].push(thisItem);
				if(thisItem.yPerSample[sampleIndex] > maxY){
					maxY = thisItem.yPerSample[sampleIndex];
				}
			break;
		}else{
			dist = -1;
		}
	}
	if(dist < 0){
		levels[0].push(thisItem);
	}

	
}
mean = mean/population.length;
yScale = d3.scale.linear().range([areaBottomY,Math.max(areaBottomY - maxY,areaTopY+radius*2)]);
yScale.domain([0,maxY]);
for(var l = 0; l<itemsToHeap.length;l++){
	itemsToHeap[l].yPerSample[sampleIndex] = yScale(itemsToHeap[l].yPerSample[sampleIndex]);
}
return mean;
}